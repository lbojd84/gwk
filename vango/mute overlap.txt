1. two continous sound should be overlapped 2 sounds.
2. there should be a banlance between video and sound.

example 1:
time  :   0-----1-----2-----3-----4-----5-----6-----7-----8-----9
sound1:   |-----------------------------|
sound2:                     |-----------------------------------|

0s sound1 come in, add fade in for sound1, fade form 0s to 2s, volume from 0 to 1.
3s sound1 go out, add fade out for sound1, fade from 3s to 5s, volume from 1 to 0.
3s sound2 come in, add fade in for sound2, fade from 3s to 5s, volume from 0 to 1.
7s sound2 go out, add fade out for sound2, fade from 7s to 9s, volume from 1 to 0.

example 2:
time  :   0-----1-----2-----3-----4-----5-----6-----7-----8-----9
video :                           |-----------------------|
sound1:   |-----------------------------|
sound2:                     |-----------------------------------|

if on 4s, a video come in, the fade in of the sound2 should be modified to V. A 
banlaced value for sound and video.
0s sound1 ...
3s sound1 ...
3s sound2 come in, add fade in for sound2, fade from 3s to 5s, volume from 0 to V.
4s~6s the volume of the sound is V.
6s video go out, add fade out for sound2, fade from 6s to 8s, fade from V to 1.
8s sound2 go out, add fade out for sound2, fade from 8s to 9s, fade from 1 to 0.

	As we can see, the situation can be complexed. Because the video can come in 
and go out at anytime.

[Solution]
Simplify: Every sound over is with a sound begin. We no need to detect the video 
for both sound over and sound begin. So we just cosider the situation of no  
overlap, and then add the mute for mute begin at each sound over.

1. Sound Begin -> Sound Over
time  :   0-----1-----2-----3-----4-----5-----6-----7-----8-----9
sound1:   |-----------------------------|
sound2:                                 |-----------------------|

2. Sound Over -> Sound Begin
time  :   0-----1-----2-----3-----4-----5-----6-----7-----8-----9
sound1:   |-----------------------------|
sound2:                                 |-----------------------|

3. Sound Begin -> Mute Begin
time  :   0-----1-----2-----3-----4-----5-----6-----7-----8-----9
video :               |-----------------------|
sound :   |-----------------------------|

4. Mute Over -> Mute Begin
time  :   0-----1-----2-----3-----4-----5-----6-----7-----8-----9
video :         |-----------------------|     |-----------|
sound :   |-----------------------------------------|

5. Mute Begin -> Mute Over
time  :   0-----1-----2-----3-----4-----5-----6-----7-----8-----9
video :               |-----------------------|
sound :   |-----------------------------------------|

6. Mute Over -> Sound Over
time  :   0-----1-----2-----3-----4-----5-----6-----7-----8-----9
video :         |-----------------------|     
sound :   |-----------------------------------------|

[Conflict]
Sound Begin
Conflict 1
time  :   0-----1-----2-----3-----4-----5-----6-----7-----8-----9
video :               |-----------------------|     
sound :   |-----------------------------------#-----|

Conflict 2
time  :   0-----1-----2-----3-----4-----5-----6-----7-----8-----9
video :                     |-----------------------|     
sound :   |-----------------#-----|

Mute Begin
Conflict 3
time  :   0-----1-----2-----3-----4-----5-----6-----7-----8-----9
video :               |-----------------------|     
sound :   |-----------------------------#|

Mute Over
Conflict 4
time  :   0-----1-----2-----3-----4-----5-----6-----7-----8-----9
video :         |-----------------------|     
sound :   |-----------------------------#-----|


[Pseudocode]
state := START
while true {
	switch state {
	case SOUND_BEGIN:
		if flag_in_mute {
			vol := V
			if mute.EndTime > sound.EndTime {
				state = MUTE_OVER
				if mute.EndTime - sound.BeginTime < 2 {
					// Conflict 1.
					vol = 1
				}
			} else {
				state = SOUND_OVER
			}
			AddMute(sound, from:0 , to:vol)
		} else {
			vol := 1
			if sound.EndTime > mute.BeginTime {
				state = MUTE_BEGIN
				if mute.BeginTime - sound.BeginTime < 2 {
					// Conflict 2
					vol = V
				}
			} else {
				state = SOUND_VOER
			}
			AddMute(sound, from:0, to:vol)
		}
		break
	case MUTE_BEGIN:
		if sound.EndTime - mute.EndTime < 2 {
			// Conflict 3
			AddMute(sound, from:1, to:0)
			sound.FlagFadeOut = true
		} else {
			AddMute(sound, from:1, to:V)
		}

		if mute and sound.EndTime < mute.EndTime {
			state = SOUND_OVER
		} else {
			state = MUTE_OVER
		}

		flag_in_mute = true
		break
	case SOUND_OVER:
		if sound.FlagFadeOut {
			// Hanlded in MUTE_BEGIN and MUTE_OVER
		} else if pre_state == MUTE_BEGIN {
			AddMute(sound, from:V, to:0)
		} else {
			AddMute(sound, form:1, to:0)
		}

		state = SOUND_BEGIN

		sound = nextSound()
		if sounds is over {
			state = OVER
			break while loop.
		}
		break:
	case MUTE_OVER:
		if sound.EndTime - mute.EndTime < 2 {
			// Conflict 4
			AddMute(sound, from:V, to:0)
			sound.FlagFadeOut = true
		} else {
			AddMute(sound, from:V, to:1)
		}

		state = SOUND_OVER

		mute = nextMute()
		if mutes is over {
			mute = nil
		} else {
			if mute.BeginTime < sound.EndTime {
				state = MUTE_BEGIN
			} else {
				state = SOUND_OVER
			}
		}
		flag_in_mute = false
		break
	}
}